<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>f64ad</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="getting_started/getting_started_0.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/f64ad_installation.html"><strong aria-hidden="true">1.1.</strong> f64ad Installation</a></li><li class="chapter-item expanded "><a href="getting_started/rust_installation.html"><strong aria-hidden="true">1.2.</strong> Rust Installation</a></li><li class="chapter-item expanded "><a href="getting_started/citing_f64ad.html"><strong aria-hidden="true">1.3.</strong> Citing f64ad</a></li></ol></li><li class="chapter-item expanded "><a href="examples/examples_0.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/example1_univariate_autodiff.html"><strong aria-hidden="true">2.1.</strong> Univariate Autodiff</a></li><li class="chapter-item expanded "><a href="examples/example2_backwards_mode_multivariate_autodiff.html"><strong aria-hidden="true">2.2.</strong> Backwards Mode Multivariate Autodiff</a></li><li class="chapter-item expanded "><a href="examples/example3_forward_mode_multivariate_autodiff.html"><strong aria-hidden="true">2.3.</strong> Forward Mode Multivariate Autodiff</a></li><li class="chapter-item expanded "><a href="examples/example4_polymorphism.html"><strong aria-hidden="true">2.4.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="examples/example5_univariate_higher_order_derivatives.html"><strong aria-hidden="true">2.5.</strong> Univariate Higher Order Derivatives</a></li><li class="chapter-item expanded "><a href="examples/example6_multivariate_higher_order_derivatives.html"><strong aria-hidden="true">2.6.</strong> Multivariate Higher Order Derivatives</a></li><li class="chapter-item expanded "><a href="examples/example7_locked_computation_graphs.html"><strong aria-hidden="true">2.7.</strong> Locked Computation Graphs</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">f64ad</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="f64ad"><a class="header" href="#f64ad">f64ad</a></h1>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This crate brings easy to use, efficient, and highly flexible automatic differentiation to the
Rust programming language.  Utilizing Rust's extensive operator overloading and expressive Enum
features, f64ad can be thought of as a drop-in replacement for f64 that affords forward mode
or backwards mode automatic differentiation on any downstream computation in Rust.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key features</a></h2>
<ul>
<li>f64ad supports reverse mode or forward mode automatic differentiation</li>
<li>f64ad uses polymorphism such that any <code>f64ad</code> object can either be considered a derivative 
tracking variable or a standard f64 with very little overhead depending on your current use case.
Thus, it is reasonable to replace almost all uses of f64 with f64ad, and in return, you'll be able<br />
to &quot;turn on&quot; derivatives with respect to these values whenever you need them.</li>
<li>The f64ad Enum type implements several useful traits that allow it to operate almost exactly as a
standard f64.  For example, it even implements the <code>RealField</code> and <code>ComplexField</code> traits,
meaning it can be used in any <code>nalgebra</code> or <code>ndarray</code> computations.</li>
<li>Certain functions can be pre-computed and locked to boost performance at run-time.</li>
</ul>
<h2 id="crate-structure"><a class="header" href="#crate-structure">Crate structure</a></h2>
<p>This crate is a cargo workspace with two member crates: (1) <code>f64ad_core</code>; and (2) <code>f64ad_core_derive</code>.
All core implementations for f64ad can be found in <code>f64ad_core</code>.  The <code>f64ad_core_derive</code> is
currently a placeholder and will be used for procedural macro implementations.</p>
<h2 id="implementation-note-on-unsafe-code"><a class="header" href="#implementation-note-on-unsafe-code">Implementation note on unsafe code</a></h2>
<p>This crate uses <code>unsafe</code> implementations under the hood.  I tried to avoid using unsafe, but
I deemed it necessary in this case.  Without using unsafe code, I had two other options:
(1) <code>f64ad_var</code> could've used a smart pointer that cannot implement the <code>Copy</code> trait and, thus,
<code>f64ad</code> could not be <code>Copy</code> either.  This would mean that f64ad could not be an easy drop-in
replacement for f64 as annoying .clone() functions would have to be littered everywhere; or (2)
<code>f64ad_var</code> could've used a reference to some smart pointer, such as <code>&amp;RefCell</code>.  However, certain
libraries, such as <code>nalgebra</code>, require their generic inputs to be static,
meaning the reference would've had to be <code>&amp;'static RefCell</code> in <code>f64ad_var</code>.  In turn,
<code>ComputationGraph</code> would also have to be static, meaning it would essentially have to be a
mutable global static variable that would involve unsafe code anyway.  In the end, I viewed
an <code>unsafe</code> raw pointer to a <code>ComputationGraph</code> as the &quot;best&quot; among three sub-optimal
options.</p>
<p>I was very careful with my internal implementations given the unsafe nature of the computations;
however, PLEASE be aware that the computation graph should NEVER GO OUT OF SCOPE IF ANY OF
ITS VARIABLES ARE STILL IN USE.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In this Chapter, I will overview how to set up f64ad.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f64ad-installation"><a class="header" href="#f64ad-installation">f64ad Installation</a></h1>
<p>The f64ad code lives on <a href="https://github.com/djrakita/f64ad">github</a>.  A standard way to install this code is to ensure that <a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">git</a> is installed on your system, then <a href="https://www.w3schools.com/git/git_clone.asp?remote=github">clone</a> the code by running the following command in your terminal after navigating to a desired directory:</p>
<pre><code>git clone https://github.com/djrakita/f64ad.git
</code></pre>
<p>And that's it!  The f64ad files are now on your computer.  In the following section, I will outline how to install the Rust toolchain in order to further set up the Optima Toolbox.   </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-installation"><a class="header" href="#rust-installation">Rust Installation</a></h1>
<p>We will next ensure that the <a href="https://www.rust-lang.org/">Rust programming language</a> toolchain is installed on your computer.  Rust is required in order to set up and compile all of the features offered by Optima, even if you are mostly interested in using Optima in Python, Webassembly, etc.</p>
<p>Fortunately, the Rust toolchain is very easy to install.  Simply follow the one-step installation guide <a href="https://www.rust-lang.org/learn/get-started">here</a>.  To verify that Rust has been successfully installed, run the following command:</p>
<pre><code class="language-shell">cargo --version
</code></pre>
<p>Also, to verify that the newly installed Rust compiler works with f64ad, navigate to the <code>f64ad</code> directory, then run</p>
<pre><code>cargo test
</code></pre>
<p>Numerous tests should run, all passing with a result of <code>ok</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="citing-f64ad"><a class="header" href="#citing-f64ad">Citing f64ad</a></h1>
<p>If you use any part of the f64ad library in your research, please cite the software as follows:</p>
<pre><code class="language-string"> @misc{rakita_2022, url={https://djrakita.github.io/f64ad/}, 
 author={Rakita, Daniel}, 
 title={f64ad: Efficient and Flexible Automatic Differentiation in Rust}
 year={2022}} 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>In this Chapter, I will go through some examples that use f64ad.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-univariate-autodiff"><a class="header" href="#example-1-univariate-autodiff">Example 1: Univariate Autodiff</a></h1>
<pre><pre class="playground"><code class="language-rust">extern crate f64ad;
use f64ad_core::ComplexField;
use f64ad_core::f64ad::{ComputationGraph, ComputationGraphMode};

fn main() {
    // Create a standard computation graph.
    let mut computation_graph = ComputationGraph::new(ComputationGraphMode::Standard, None);

    // Spawn an f64ad variable with a value of 2.
    let v = computation_graph.spawn_f64ad_var(2.0);

    // You can now use an f64ad exactly the same as you would use a standard f64.  In this example,
    // we are just using the `powi` function to take v to the third power.
    let result = v.powi(3);
    println!(&quot;Result of v.powi(3): {:?}&quot;, result);

    // We can now find the derivative of our just computed function with respect to our input variable,
    // `v`.

    // We can do this in one of two ways.  First, we can use backwards mode autodiff, meaning we
    // call `backwards_mode_grad` on our output result wrt our input variable, `v`:
    let backwards_mode_derivative = result.backwards_mode_grad(false).wrt(&amp;v);

    // Alternatively, we can use forward mode autodiff, meaning we call `forward_mode_grad` on
    // our input variable `v` wrt to our output variable, `result`.
    let forward_mode_derivative = v.forward_mode_grad(false).wrt(&amp;result);

    // Both methods will output the same derivative.
    println!(&quot;Backwards mode derivative: {:?}&quot;, backwards_mode_derivative);
    println!(&quot;Forward mode derivative: {:?}&quot;, forward_mode_derivative);
}
</code></pre></pre>
<p>Output</p>
<pre><code class="language-text">Result of v.powi(3): f64ad_var(f64ad_var{ value: 8.0, node_idx: 1 })
Backwards mode derivative: f64(12.0)
Forward mode derivative: f64(12.0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-2-backwards-mode-multivariate-autodiff"><a class="header" href="#example-2-backwards-mode-multivariate-autodiff">Example 2: Backwards Mode Multivariate Autodiff</a></h1>
<pre><pre class="playground"><code class="language-rust">use f64ad_core::ComplexField;
use f64ad_core::f64ad::{ComputationGraph, ComputationGraphMode};

fn main() {
    // Create a standard computation graph.
    let mut computation_graph = ComputationGraph::new(ComputationGraphMode::Standard, None);

    // Spawn an f64ad variables from computation graph.
    let v0 = computation_graph.spawn_f64ad_var(2.0);
    let v1 = computation_graph.spawn_f64ad_var(4.0);
    let v2 = computation_graph.spawn_f64ad_var(6.0);
    let v3 = computation_graph.spawn_f64ad_var(8.0);

    // compute some result using our variables
    let result = v0.sin() * v1 + 5.0 * v2.log(v3);
    println!(&quot;Result: {:?}&quot;, result);

    // compute derivatives in backwards direction from result.  Using backwards mode automatic
    // differentiation makes sense in this case because our number of outputs (1) is less than
    // our number of input variables (4).
    let derivatives = result.backwards_mode_grad(false);

    // access derivatives for each input variable from our `derivatives` object.
    let d_result_d_v0 = derivatives.wrt(&amp;v0);
    let d_result_d_v1 = derivatives.wrt(&amp;v1);
    let d_result_d_v2 = derivatives.wrt(&amp;v2);
    let d_result_d_v3 = derivatives.wrt(&amp;v3);

    // print results
    println!(&quot;d_result_d_v0: {:?}&quot;, d_result_d_v0);
    println!(&quot;d_result_d_v1: {:?}&quot;, d_result_d_v1);
    println!(&quot;d_result_d_v2: {:?}&quot;, d_result_d_v2);
    println!(&quot;d_result_d_v3: {:?}&quot;, d_result_d_v3);
}
</code></pre></pre>
<p>Output</p>
<pre><code class="language-text">Result: f64ad_var(f64ad_var{ value: 7.9454605418379876, node_idx: 8 })
d_result_d_v0: f64(-1.6645873461885696)
d_result_d_v1: f64(0.9092974268256817)
d_result_d_v2: f64(0.40074862246915655)
d_result_d_v3: f64(-0.25898004032460736)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-3-forward-mode-multivariate-autodiff"><a class="header" href="#example-3-forward-mode-multivariate-autodiff">Example 3: Forward Mode Multivariate Autodiff</a></h1>
<pre><pre class="playground"><code class="language-rust">use f64ad_core::ComplexField;
use f64ad_core::f64ad::{ComputationGraph, ComputationGraphMode};

fn main() {
    // Create a standard computation graph.
    let mut computation_graph = ComputationGraph::new(ComputationGraphMode::Standard, None);

    // Spawn an f64ad variable with a value of 2.
    let v = computation_graph.spawn_f64ad_var(2.0);

    // compute some results using our variable
    let result0 = v.sin();
    let result1 = v.cos();
    let result2 = v.tan();
    println!(&quot;Result0: {:?}&quot;, result0);
    println!(&quot;Result1: {:?}&quot;, result1);
    println!(&quot;Result2: {:?}&quot;, result2);

    // compute derivatives in forward direction from v.  Using forward mode automatic
    // differentiation makes sense in this case because our number of outputs (3) is greater than
    // our number of input variables (1).
    let derivatives = v.forward_mode_grad(false);

    // access derivatives for each input variable from our `derivatives` object.
    let d_result0_d_v = derivatives.wrt(&amp;result0);
    let d_result1_d_v = derivatives.wrt(&amp;result1);
    let d_result2_d_v = derivatives.wrt(&amp;result2);

    // print results
    println!(&quot;d_result0_d_v: {:?}&quot;, d_result0_d_v);
    println!(&quot;d_result1_d_v: {:?}&quot;, d_result1_d_v);
    println!(&quot;d_result2_d_v: {:?}&quot;, d_result2_d_v);
}
</code></pre></pre>
<p>Output</p>
<pre><code class="language-text">Result0: f64ad_var(f64ad_var{ value: 0.9092974268256817, node_idx: 1 })
Result1: f64ad_var(f64ad_var{ value: -0.4161468365471424, node_idx: 2 })
Result2: f64ad_var(f64ad_var{ value: -2.185039863261519, node_idx: 3 })
d_result0_d_v: f64(-0.4161468365471424)
d_result1_d_v: f64(-0.9092974268256817)
d_result2_d_v: f64(5.774399204041917)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-4-polymorphism"><a class="header" href="#example-4-polymorphism">Example 4: Polymorphism</a></h1>
<pre><pre class="playground"><code class="language-rust">extern crate f64ad as f64ad_crate;
use f64ad_core::f64ad::{ComputationGraph, ComputationGraphMode, f64ad};

// f64ad is an enum here that is a drop-in replacement for f64.  It can track derivative information
// for both, either, or neither of the variables, you can select what you want depending on your
// application at the time.
fn f64ad_test(a: f64ad, b: f64ad) -&gt; f64ad {
    return a + b;
}

fn main() {
    let mut computation_graph = ComputationGraph::new(ComputationGraphMode::Standard, None);
    let a = computation_graph.spawn_f64ad_var(1.0);
    let b = computation_graph.spawn_f64ad_var(2.0);

    // Compute result using two f64ad variables that track derivative information for both `a` and `b'.
    let result1 = f64ad_test(a, b);
    println!(&quot;result 1: {:?}&quot;, result1.value());

    ////////////////////////////////////////////////////////////////////////////////////////////////

    let mut computation_graph = ComputationGraph::new(ComputationGraphMode::Standard, None);
    let a = computation_graph.spawn_f64ad_var(1.0);

    // Compute result using one f64ad variables that only tracks derivative information for `a'.
    let result2 = f64ad_test(a, f64ad::f64(2.0));
    println!(&quot;result 2: {:?}&quot;, result2.value());

    ////////////////////////////////////////////////////////////////////////////////////////////////

    // Compute result using zero f64ad variables.  This operation will not keep track of derivative information
    // for any variable and will essentially run as normal f64 floats with almost no overhead.
    let result3 = f64ad_test(f64ad::f64(1.0), f64ad::f64(2.0));
    println!(&quot;result 3: {:?}&quot;, result3.value());
}
</code></pre></pre>
<p>Output</p>
<pre><code class="language-text">result 1: 3.0
result 2: 3.0
result 3: 3.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-5-univariate-higher-order-derivatives"><a class="header" href="#example-5-univariate-higher-order-derivatives">Example 5: Univariate Higher Order Derivatives</a></h1>
<pre><pre class="playground"><code class="language-rust">use f64ad_core::ComplexField;
use f64ad_core::f64ad::{ComputationGraph, ComputationGraphMode};

fn main() {
    // Create a standard computation graph.
    let mut computation_graph = ComputationGraph::new(ComputationGraphMode::Standard, None);

    // Spawn an f64ad variables from computation graph.
    let v = computation_graph.spawn_f64ad_var(2.0);

    let result = v.powi(5);
    println!(&quot;Result: {:?}&quot;, result);
    println!(&quot;////////////////////////////////////////////////////////////////////////////////////&quot;);

    // first derivative computations...
    // we must set the parameter `add_to_computation_graph` to `true`
    let derivatives = result.backwards_mode_grad(true);
    let d_result_d_v = derivatives.wrt(&amp;v);
    println!(&quot;d_result_d_v: {:?}&quot;, d_result_d_v);
    println!(&quot;////////////////////////////////////////////////////////////////////////////////////&quot;);

    // second derivative computations...
    // we must set the parameter `add_to_computation_graph` to `true`
    let derivatives = d_result_d_v.backwards_mode_grad(true);
    let d2_result_d_v2 = derivatives.wrt(&amp;v);
    println!(&quot;d2_result_d_v2: {:?}&quot;, d2_result_d_v2);
    println!(&quot;////////////////////////////////////////////////////////////////////////////////////&quot;);

    // third derivative computations...
    // we must set the parameter `add_to_computation_graph` to `true`
    let derivatives = d2_result_d_v2.backwards_mode_grad(true);
    let d3_result_d_v3 = derivatives.wrt(&amp;v);
    println!(&quot;d3_result_d_v3: {:?}&quot;, d3_result_d_v3);
    println!(&quot;////////////////////////////////////////////////////////////////////////////////////&quot;);

    // fourth derivative computations...
    // we must set the parameter `add_to_computation_graph` to `true`
    let derivatives = d3_result_d_v3.backwards_mode_grad(true);
    let d4_result_d_v4 = derivatives.wrt(&amp;v);
    println!(&quot;d4_result_d_v4: {:?}&quot;, d4_result_d_v4);
    println!(&quot;////////////////////////////////////////////////////////////////////////////////////&quot;);

    // fifth derivative computations...
    // we must set the parameter `add_to_computation_graph` to `true`
    let derivatives = d4_result_d_v4.backwards_mode_grad(true);
    let d5_result_d_v5 = derivatives.wrt(&amp;v);
    println!(&quot;d5_result_d_v5: {:?}&quot;, d5_result_d_v5);
    println!(&quot;////////////////////////////////////////////////////////////////////////////////////&quot;);

    // sixth derivative computations...
    // we must set the parameter `add_to_computation_graph` to `true`
    let derivatives = d5_result_d_v5.backwards_mode_grad(true);
    let d6_result_d_v6 = derivatives.wrt(&amp;v);
    println!(&quot;d6_result_d_v6: {:?}&quot;, d6_result_d_v6);
    println!(&quot;////////////////////////////////////////////////////////////////////////////////////&quot;);
}
</code></pre></pre>
<p>Output</p>
<pre><code class="language-text">Result: f64ad_var(f64ad_var{ value: 32.0, node_idx: 1 })
////////////////////////////////////////////////////////////////////////////////////
d_result_d_v: f64ad_var(f64ad_var{ value: 80.0, node_idx: 6 })
////////////////////////////////////////////////////////////////////////////////////
d2_result_d_v2: f64ad_var(f64ad_var{ value: 160.0, node_idx: 23 })
////////////////////////////////////////////////////////////////////////////////////
d3_result_d_v3: f64ad_var(f64ad_var{ value: 240.0, node_idx: 80 })
////////////////////////////////////////////////////////////////////////////////////
d4_result_d_v4: f64ad_var(f64ad_var{ value: 240.0, node_idx: 249 })
////////////////////////////////////////////////////////////////////////////////////
d5_result_d_v5: f64ad_var(f64ad_var{ value: 120.0, node_idx: 706 })
////////////////////////////////////////////////////////////////////////////////////
d6_result_d_v6: f64ad_var(f64ad_var{ value: 0.0, node_idx: 1888 })
////////////////////////////////////////////////////////////////////////////////////
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-6-multivariate-higher-order-derivatives"><a class="header" href="#example-6-multivariate-higher-order-derivatives">Example 6: Multivariate Higher Order Derivatives</a></h1>
<pre><pre class="playground"><code class="language-rust">use f64ad_core::ComplexField;
use f64ad_core::f64ad::{ComputationGraph, ComputationGraphMode};

fn main() {
    // Create a standard computation graph.
    let mut computation_graph = ComputationGraph::new(ComputationGraphMode::Standard, None);

    // Spawn an f64ad variables from computation graph.
    let v0 = computation_graph.spawn_f64ad_var(2.0);
    let v1 = computation_graph.spawn_f64ad_var(4.0);

    let result = v0.powf(v1);
    println!(&quot;Result: {:?}&quot;, result);
    println!(&quot;////////////////////////////////////////////////////////////////////////////////////&quot;);

    // first derivative computations...
    let derivatives = result.backwards_mode_grad(true);

    let d_result_d_v0 = derivatives.wrt(&amp;v0);
    let d_result_d_v1 = derivatives.wrt(&amp;v1);
    println!(&quot;d_result_d_v0: {:?}&quot;, d_result_d_v0);
    println!(&quot;d_result_d_v0: {:?}&quot;, d_result_d_v1);
    println!(&quot;////////////////////////////////////////////////////////////////////////////////////&quot;);

    // second derivative computations...
    let derivatives2_d_result_d_v0 = d_result_d_v0.backwards_mode_grad(true);
    let derivatives2_d_result_d_v1 = d_result_d_v1.backwards_mode_grad(true);

    let d2_result_dv0v0 = derivatives2_d_result_d_v0.wrt(&amp;v0);
    let d2_result_dv0v1 = derivatives2_d_result_d_v0.wrt(&amp;v1);
    let d2_result_dv1v0 = derivatives2_d_result_d_v1.wrt(&amp;v0);
    let d2_result_dv1v1 = derivatives2_d_result_d_v1.wrt(&amp;v1);
    println!(&quot;d2_result_dv0v0: {:?}&quot;, d2_result_dv0v0);
    println!(&quot;d2_result_dv0v1: {:?}&quot;, d2_result_dv0v1);
    println!(&quot;d2_result_dv1v0: {:?}&quot;, d2_result_dv1v0);
    println!(&quot;d2_result_dv1v1: {:?}&quot;, d2_result_dv1v1);
    println!(&quot;////////////////////////////////////////////////////////////////////////////////////&quot;);

    // etc...
}
</code></pre></pre>
<p>Output</p>
<pre><code class="language-text">Result: f64ad_var(f64ad_var{ value: 16.0, node_idx: 2 })
////////////////////////////////////////////////////////////////////////////////////
d_result_d_v0: f64ad_var(f64ad_var{ value: 32.0, node_idx: 11 })
d_result_d_v0: f64ad_var(f64ad_var{ value: 11.090354888959125, node_idx: 13 })
////////////////////////////////////////////////////////////////////////////////////
d2_result_dv0v0: f64ad_var(f64ad_var{ value: 48.0, node_idx: 66 })
d2_result_dv0v1: f64ad_var(f64ad_var{ value: 30.18070977791825, node_idx: 68 })
d2_result_dv1v0: f64ad_var(f64ad_var{ value: 30.18070977791825, node_idx: 290 })
d2_result_dv1v1: f64ad_var(f64ad_var{ value: 7.687248222691222, node_idx: 292 })
////////////////////////////////////////////////////////////////////////////////////
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-7-locked-computation-graphs"><a class="header" href="#example-7-locked-computation-graphs">Example 7: Locked Computation Graphs</a></h1>
<p>Any computations that do not have any conditional branches can be pre-computed and locked using a <code>LockedComputationGraph</code> in f64ad.  Any computation that falls into this category</p>
<pre><pre class="playground"><code class="language-rust">use f64ad_core::ComplexField;
use f64ad_core::f64ad::{ComputationGraph, ComputationGraphMode};

fn main() {
    // Create a computation graph with mode `Lock`.  This signals that all computations that happen
    // on this graph will eventually be locked and, thus, only certain programs without conditional
    // branching will be compatible.  Any incompatible programs will panic.
    let mut computation_graph = ComputationGraph::new(ComputationGraphMode::Lock, None);
    let v = computation_graph.spawn_f64ad_var(3.0);

    let result = v.cos();

    // This locks the computation graph.  The `result` variable is taken as input here and is stored
    // by the locked graph.
    let mut function_locked_computation_graph = computation_graph.lock(None, result);

    // We can now replace the value of `v` here and use the `push_forward_compute` function to
    // recompute all downstream values on the locked function.
    function_locked_computation_graph.set_value(0, 0.0);
    function_locked_computation_graph.push_forward_compute();
    let new_output = function_locked_computation_graph.get_value(function_locked_computation_graph.template_output().node_idx());
    println!(&quot;v.cos() at v = 0.0: {:?}&quot;, new_output);

    // Here is another example where `v` is set with a value of 1.0.
    function_locked_computation_graph.set_value(0, 1.0);
    function_locked_computation_graph.push_forward_compute();
    let new_output = function_locked_computation_graph.get_value(function_locked_computation_graph.template_output().node_idx());
    println!(&quot;v.cos() at v = 1.0: {:?}&quot;, new_output);
    println!(&quot;////////////////////////////////////////////////////////////////////////////////////&quot;);

    // Because derivative/ gradient computations do not ever require conditional branching,
    // any derivatives over any compatible lockable functions can be locked as well.
    let derivatives = result.backwards_mode_grad(true);
    let derivative = derivatives.wrt(&amp;v);
    let mut derivative_locked_computation_graph = computation_graph.lock(None, derivative);

    // Here, we are pushing forward the computation on the derivative of v.cos() at v = 0.0
    derivative_locked_computation_graph.set_value(0, 0.0);
    derivative_locked_computation_graph.push_forward_compute();
    let new_output = derivative_locked_computation_graph.get_value(derivative_locked_computation_graph.template_output().node_idx());
    println!(&quot;derivative of v.cos() at v = 0.0: {:?}&quot;, new_output);

    // Here, we are pushing forward the computation on the derivative of v.cos() at v = 1.0
    derivative_locked_computation_graph.set_value(0, 1.0);
    derivative_locked_computation_graph.push_forward_compute();
    let new_output = derivative_locked_computation_graph.get_value(derivative_locked_computation_graph.template_output().node_idx());
    println!(&quot;derivative of v.cos() at v = 1.0: {:?}&quot;, new_output);

    // Locked computation graphs can also spawn `locked_vars`.  These are also variants of the f64ad
    // Enum, thus they can also operate in any function.  However, after spawning variables, all downstream
    // computations must be EXACTLY THE SAME as the functions used on the original ComputationGraph
    // prior to locking (if functions are different, an error will be thrown).  Thus, in this example,
    // we call v.cos() on the locked_var because it is the same as the original computation above.
    // The locked_computation_graph then automatically updates its internal data and correctly
    // computes the derivative after the push_forward_compute function.
    let v = derivative_locked_computation_graph.spawn_locked_var(2.0);
    v.cos();
    derivative_locked_computation_graph.push_forward_compute();
    let new_output = derivative_locked_computation_graph.get_value(derivative_locked_computation_graph.template_output().node_idx());
    println!(&quot;derivative of v.cos() at v = 2.0: {:?}&quot;, new_output);
}
</code></pre></pre>
<p>Output</p>
<pre><code class="language-text">v.cos() at v = 0.0: 1.0
v.cos() at v = 1.0: 0.5403023058681398
////////////////////////////////////////////////////////////////////////////////////
derivative of v.cos() at v = 0.0: 0.0
derivative of v.cos() at v = 1.0: -0.8414709848078965
derivative of v.cos() at v = 2.0: -0.9092974268256817
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
